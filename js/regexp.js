//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions
//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes
//////////////////////
//\ d - те саме, що [0-9],
//\ w - те саме, що [a-zA-Z0-9_],
//\ s - те саме [\t\n\v\f\r ], що і декілька інших рідкісних символів пробілу Unicode.

// \d - Відповідає будь-якій цифрі (арабською цифрою). Еквівалентно [0-9]. Наприклад, / \ d / або / [0-9] / відповідає "2" у "B2 - номер набору".
// \D - Відповідає будь-якому символу, який не є цифрою (арабською цифрою). Еквівалентно [^ 0-9]. Наприклад, / \ D / або / [^ 0-9] / відповідає "B" у "B2 - номер набору".
// \w - Відповідає будь-якому буквено-цифровому символу з основного латинського алфавіту, включаючи підкреслення. Еквівалентно [A-Za-z0-9_]. Наприклад, / \ w / відповідає "a" в "apple", "5" у "$ 5.28" та "3" у "3D".
// \W - Відповідає будь-якому символу, який не є символом слова, з основного латинського алфавіту. Еквівалентно [^ A-Za-z0-9_]. Наприклад, / \ W / або / [^ A-Za-z0-9 _] / відповідає "%" в "50%".
// \s - Збігає один пробіл із пробілом, включаючи пробіл, вкладку, канал форми, канал рядків та інші пробіли Unicode. Еквівалентно [\ f \ n \ r \ t \ v \ u00a0 \ u1680 \ u2000- \ u200a \ u2028 \ u2029 \ u202f \ u205f \ u3000 \ ufeff]. Наприклад, / \ s \ w * / відповідає "bar" у "foo bar".
// \S - Відповідає одному символу, відмінному від пробілу. Еквівалентно [^ \ f \ n \ r \ t \ v \ u00a0 \ u1680 \ u2000- \ u200a \ u2028 \ u2029 \ u202f \ u205f \ u3000 \ ufeff]. Наприклад, / \ S \ w * / відповідає "foo" в "foo bar".
// \t - Відповідає горизонтальній вкладці. Відповідає поверненню каретки.
// \n - Збігає лінійку прямих передач.
// \v - Відповідає вертикальній вкладці.
// \f - Відповідає подачі форми.
// [\b] - Збігає зворотній простір. Якщо ви шукаєте символу граничного слова (\ b), див. Межі.
// \0 - Відповідає символу NUL. Не слідкуйте за цим іншою цифрою.
// ^ - Відповідає початку введення.
// $ - Відповідає в кінці введення.
// /\bm/ - відповідає "m" у "moon". / oo \ b / не відповідає "oo" у "місяці", оскільки "oo" супроводжується "n", що є символом слова. / oon \ b / відповідає "oon" у "moon", оскільки "oon" - це кінець рядка, тому не слідує символ слова.
// /\w\b\w/ -  ніколи нічого не відповідатиме, тому що за символом слова ніколи не може супроводжуватися як слово, так і слово.
// \B - Відповідає межі без слів. Це положення, коли попередній і наступний символи мають один і той же тип: або обидва повинні бути словами, або обидва повинні бути не словами, наприклад між двома літерами або між двома пробілами. Початок і кінець рядка вважаються несловами. Подібно до межі відповідного слова, відповідна межа без слів також не включається в збіг. Наприклад, / \ Bon / match "on" in "опівдні", і / ye \ B / match "ye" в „можливо вчора".
// x(?=y) - Заява Lookahead: відповідає "x", лише якщо "x" супроводжується "y". Наприклад, / Jack (? = Sprat) / відповідає "Jack", лише якщо за ним слідує "Sprat".
// /Jack(?=Sprat|Frost)/ - відповідає "Jack", лише якщо за ним слід "Sprat" або "Frost". Однак ні "Спрат", ні "Мороз" не є частиною результатів матчу.
// х(?!у) - Негативне твердження пошуку: відповідає "x", лише якщо "x" не супроводжується "y". Наприклад, /\d+(?!\.)/ відповідає номеру лише в тому випадку, якщо за ним не стоїть десяткова крапка. /\d+(?!\.)/.exec('3.141 ') відповідає "141", але не "3.
// (?<=y)x - Попередження твердження: відповідає "x", тільки якщо "x" передує "y". Наприклад, / (? <= Jack) Спрат / відповідає "Спрат", лише якщо йому передує "Джек". / (? <= Jack | Tom) Спрат / відповідає "Спрат", лише якщо йому передує "Джек" або "Том". Однак ні "Джек", ні "Том" не є частиною результатів матчу.
// (?<!y)х - Негативний погляд за твердженням: відповідає "x", лише якщо "x" не передує "y". Наприклад, / (? <! -) \ d + / відповідає номеру, лише якщо йому не передує знак мінус. /(?<!-)\d+/.exec('3 ') відповідає "3". /(?<!-)\d+/.exec('-3 ') збіг не знайдено, оскільки число передує знаку мінус.



//шукає будь-які символи, крім букв, цифр та пробілів:
alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ and .
//kim
const REGEXP = /[^0-9\sA-Za-z]/gi


//Непарні числа
let x = /^\d*[13579]$/
//Парні числа
let x = /^\d*[24680]$/



//      /^[^C]/.     фільтрує всі слова де на початку є велика буква С
//      /[^C]/.      фільтрує всі слова де є велика буква С
function acceptedWords(arr) {
	return arr.filter(el=>el=/^[^C]/.test(el));
}



//Використовуючи .test() метод у своїй функції, поверніть, чи містить рядок символи
 //"a" та "c" (у такому порядку) з будь-якою кількістю символів (включаючи нуль)
 //між ними.
asterisk("account") ➞ true
asterisk("abccount") ➞ true
asterisk("abbbccount") ➞ true
asterisk("bbbccount") ➞ false
function asterisk(string) {
	return /a.*c/.test(string)
}
//
function asterisk(string) {
	return /ab*c/.test(string)
}





//шукаємо розштрення файла в кінці .js || .jsx
//\. - для того щоб шукати з крапкою
// js - відповідає js, чутливо до регістру
// х? - відповідає символу x буквально (з урахуванням регістру)
// ?  Квантор - Матчі між нулем і один раз, (x{0,1})
// $  затверджує позицію в кінці рядка
function isJS(path) {
	return /\.jsx?$/.test(path)
}
//
const isJS = path => /(\.js|\.jsx)$/.test(path);







//kim
function isPrefix(word, prefix) {
	return RegExp('^'+prefix.replace('-', ''), 'gi').test(word);
}
function isSuffix(word, suffix) {
	return RegExp(suffix.replace('-', '')+'$', 'gi').test(word);
}
//
function isPrefix(word, prefix) {
	var reg = new RegExp('^'+prefix.replace('-',''));
	return reg.test(word)
}
function isSuffix(word, suffix) {
	var reg = new RegExp(suffix.replace('-','')+'$');
	return reg.test(word)
}
//
function isPrefix(word, prefix) {
	return word.startsWith(prefix.replace("-", ""));
}
function isSuffix(word, suffix) {
	return word.endsWith(suffix.replace("-", ""));
}
//
let isPrefix = (w, p) => w.startsWith(p.slice(0, -1));
let isSuffix = (w, s) => w.endsWith(s.slice(1));
//
Test.assertEquals(isPrefix("automation", "auto-"), true)
Test.assertEquals(isPrefix("superfluous", "super-"), true)
Test.assertEquals(isPrefix("oration", "mega-"), false)
Test.assertEquals(isPrefix("retrospect", "sub-"), false)
Test.assertEquals(isSuffix("arachnophobia", "-phobia"), true)
Test.assertEquals(isSuffix("rhinoplasty", "-plasty"), true)
Test.assertEquals(isSuffix("movement", "-scope"), false)
Test.assertEquals(isSuffix("vocation", "-logy"), false)








//kim шукає перший індекс голосної букви
function firstVowel(str) {
	let r = new RegExp('[aeoiu]', 'i');
	return str.search(r);
}
