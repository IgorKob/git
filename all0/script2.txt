







////////////////////////////Symbol
Якщо ми дійсно хочемо показати символ, нам потрібно прямо зателефонувати .toString()на нього, як ось:
let id = Symbol("id");
alert(id.toString()); // Symbol(id), now it works

Або отримайте symbol.descriptionвласність, щоб показати лише опис:
let id = Symbol("id");
alert(id.description); // id








Object.assign копіює властивості рядка та символу:

let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123










// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true







повертає ім'я глобальним символiv.
// get symbol by name
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// get name by symbol
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id





Symbol.keyForВнутрішньо використовує глобальний реєстр символів для пошуку ключа для символу. 
Отже, це не працює для неглобальних символів. Якщо символ не є глобальним, він не зможе його знайти 
і повернеться undefined.

Однак, будь-які символи мають descriptionвластивість.

let globalSymbol = Symbol.for("name");
let localSymbol = Symbol("name");

alert( Symbol.keyFor(globalSymbol) ); // name, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, not global

alert( localSymbol.description ); // name








//////////////////////////
Для здійснення перетворення JavaScript намагається знайти та викликати три об’єктні методи:

Call obj[Symbol.toPrimitive](hint)- метод із символічним ключем Symbol.toPrimitive(системний символ), якщо такий метод існує,
Інакше, якщо підказка є "string"
спробуйте, obj.toString()і obj.valueOf()все, що існує.
В іншому випадку, якщо підказка є "number"або"default"
спробуйте, obj.valueOf()і obj.toString()все, що існує.






                         toFixed (n) округляє число до заданої точності:

let n = 1.23456;
alert( n.toFixed(2) ); // 1.23





                       Існує кілька вбудованих функцій для округлення:

Math.floor
Згинається вниз: 3.1стає 3, -1.1стає -2.
Math.ceil
Обертається: 3.1стає 4, -1.1стає -1.
Math.round
Обходить до найближчого цілого числа: 3.1стає 3, 3.6стає 4і -1.1стає -1.
Math.trunc (не підтримується Internet Explorer)
Вилучає що-небудь після десяткової точки без округлення: 3.1стає 3, -1.1стає -1.








                                    Ось для чого parseIntі parseFloatє.

Вони "читають" число з рядка, поки не можуть. У разі помилки зібране число повертається. 
Функція parseIntповертає ціле число, тоді як повертає число parseFloatз плаваючою комою:

alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, only the integer part is returned
alert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading









//////////////////////.............................arr
Щоб додати / видалити елементи:

push(...items) - додає елементи до кінця,
pop() - витягує елемент з кінця,
shift() - витягує елемент з початку,
unshift(...items) - додає предмети до початку.
splice(pos, deleteCount, ...items)- при індексі posвидалити deleteCountелементи та вставити items.
slice(start, end)- створює новий масив, копіює елементи з положення startдо end(не включаючи) в нього.
concat(...items)- повертає новий масив: копіює всіх членів поточного та додає itemsдо нього. Якщо будь-який з itemsє масивом, то його елементи беруться.
Для пошуку серед елементів:

indexOf/lastIndexOf(item, pos)- шукайте, itemпочинаючи з позиції pos, поверніть індекс або -1якщо його не знайдено.
includes(value)- повертається, trueякщо масив є value, інакше false.
find/filter(func)- фільтрувати елементи через функцію, повертати спочатку / всі значення, які змушують її повернутися true.
findIndexє як find, але повертає індекс замість значення.
Щоб повторити елементи:

forEach(func)- закликає funcкожен елемент, нічого не повертає.
Для перетворення масиву:

map(func)- створює новий масив із результатів виклику func кожного елемента.
sort(func) - сортує масив на місці, а потім повертає його.
reverse() - повертає масив на місце, а потім повертає його.
split/join - перетворити рядок в масив і назад.
reduce(func, initial)- обчислити одне значення над масивом, викликавши funcкожен елемент і передаючи проміжний результат між викликами.
Додатково:

Array.isArray(arr)перевіряє arrнаявність масиву.
Зверніть увагу , що методи sort, reverseі spliceзмінювати сам масив.










arr.push(...items) - додає елементи до кінця,
arr.pop() - витягує елемент з кінця,
arr.shift() - витягує елемент з початку,
arr.unshift(...items) - додає предмети до початку.

delete arr[1];
arr.splice(index[, deleteCount, elem1, ..., elemN]) - вставляти, видаляти та замінювати елементи.


Починаючи з індексу, 0 він видалив 3 елементи і замінюємо їх іншими двома
arr.splice(0, 3, "Let's", "dance");



повертає новий масив, копіюючи на нього всі елементи з індексу startдо end(не включаючи end). 
І те, startі інше endможе бути негативним, у цьому випадку передбачається положення від кінця масиву.
arr.slice([start], [end])



 створює новий масив, який включає значення з інших масивів та додаткових елементів.
arr.concat(arg1, arg2...)




.................forEach      дозволяє запускати функцію для кожного елемента масиву
Наприклад, це показує кожен елемент масиву:
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);

І цей код є більш детальним щодо їх позицій у цільовому масиві:
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});






arr.indexOf(item, from)- шукає, itemпочинаючи з індексу from, і повертає індекс там, де його було знайдено, інакше -1.
arr.lastIndexOf(item, from) - те саме, але шукає справа наліво.
arr.includes(item, from)- шукає, itemпочинаючи з індексу from, повертає, trueякщо знайдений.




 ...............                find      знаходимо об’єкт із конкретною умовою
let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});

Наприклад, у нас є масив користувачів, кожен з полями idта name. Давайте знайдемо той, що id == 1:
let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];
let user = users.find(item => item.id == 1);

alert(user.name); // John










......................... filter      повертає масив усіх відповідних елементів:

let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});
Наприклад:

let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"}
];

// returns array of the first two users
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2







.............. arr.map - один з найкорисніших і найчастіше використовуваних.

Він викликає функцію для кожного елемента масиву і повертає масив результатів.

Синтаксис:

let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
Наприклад, тут ми перетворюємо кожен елемент на його довжину:

let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6







....................................... arr.sort () 

дозволяє записувати функції:
let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15


або


arr.sort( (a, b) => a - b );




Наприклад, давайте розберемо кілька країн німецькою мовою:

let countries = ['Osterreich', 'Andorra', 'Vietnam'];

alert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Osterreich (wrong)

alert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra, Osterreich,Vietnam (correct!)






......................... arr.reverse      повертає порядок елементів у arr.


let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1





...................... str.split (delim)       розбиває рядок на масив заданим роздільником delim.

У наведеному нижче прикладі ми розділимо комою, а потім пробілом:

let names = 'Bilbo, Gandalf, Nazgul';

let arr = names.split(', ');

for (let name of arr) {
  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)
}





.................arr.join (клей) робить зворотне значення для split.
 Створюється рядок arrоб'єднаних glueміж собою елементів .

Наприклад:

let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // glue the array into a string using ;

alert( str ); // Bilbo;Gandalf;Nazgul





....................................arr.reduce
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);

accumulator- це результат попереднього виклику функції, дорівнює initialпершого разу (якщо initialвін передбачений).
item - це поточний елемент масиву.
index - це його положення.
array - це масив.



let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15







.....................isArray()      допомагає відрізнити звичайний об’єкт від масиву:
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true



alert(typeof {}); // object
alert(typeof []); // same









//////////////////////////////////
  <style> body { color: red; margin: 5px } </style>

    let computedStyle = getComputedStyle(document.body);
    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
/////////////////////






Мишачі події:

click - коли миша клацає на елемент (пристрої з сенсорним екраном генерують його на крані).
contextmenu - коли миша клацає правою кнопкою миші на елементі.
mouseover/ mouseout- коли курсор миші переходить / залишає елемент.
mousedown/ mouseup- при натисканні / відпусканні кнопки миші над елементом.
mousemove - при переміщенні миші.
Події на клавіатурі:

keydownі keyup- при натисканні та відпуску клавіші клавіатури.
Події елемента форми:

submit- коли відвідувач подає а <form>.
focus- коли відвідувач фокусується на елементі, наприклад, на ан <input>.
Документи події:

DOMContentLoaded - коли HTML завантажується та обробляється, DOM повністю побудований.
CSS події:

transitionend - коли закінчується CSS-анімація.
////////////////////////////////////
